
[参考](https://docs.mongodb.com/manual/reference/operator/aggregation/group/)

注意: `$group` 使用的 MongoDB 版本是 > `5.0` 。

### 概述

对输入文档通过指定的 `_id` 表达式进行分组，对于每个不同的分组，输出一个文档。每个输出文档中的 `_id` 字段对应的值即为分组字段对应的值。输出文档也包含了对分组字段运用聚合运算符得到的计算结果字段。

注意: `$group` 不对输出文档进行排序。

`$group` 阶段的原型语法如下:
```js
    {
        $group:
        {
            _id: <expression>, // Group By Expression
            <field1>: { <accumulator1> : <expression1> },
            ...
        }
    }
```
- `_id`: 必选项。当该字段对应的表达式指定为空或是一个常量时，输出所有输入的文档。
- `field`: 可选项。用于计算的聚合运算符。

### 聚合表达式

可选的聚合运算符 `<accumulator>` 有:

| 名称 | 描述 |
|:----|:-----|
| `$accumulator` | 返回用户自定义的累加器函数结果 |
| `$addToSet` | 针对每个分组，返回一个唯一表达式的数组。数组元素的顺序未知 |
| `$avg` | 返回数值元素的平均值，忽略非数值元素 |
| `$count` | 返回分组中文档的数量。与管道阶段的 $count 有所不同 |
| `$first` | 为每个分组从第一个文档中返回一个值。是否有序依赖于文档是否有序 |
| `$last` | 为每个分组从最后一个文档中返回一个值。是否有序依赖于文档是否有序 |
| `$max` | 为每个分组返回最高的表达式值 |
| `$mergeObjects` | 为每个分组返回一个在合并输入文档时创建的一个文档 |
| `$min` | 为每个分组返回最低的表达式值 |
| `$push` | 在每个分组中返回文档的数组表达式 |
| `$stdDevPop` | 返回输入值的总体标准差  |
| `$stdDevSamp` | 返回输入值的样本标准差 |
| `$sum` | 返回数值的加和。忽略非数值元素 |

- [关于 $first](group-first.md)


### 示例 - 简单使用

#### 统计集合中文档的数量

创建 `sales` 集合:
```js
db.sales.insertMany([
  { "_id" : 1, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("2"), "date" : ISODate("2014-03-01T08:00:00Z") },
  { "_id" : 2, "item" : "jkl", "price" : NumberDecimal("20"), "quantity" : NumberInt("1"), "date" : ISODate("2014-03-01T09:00:00Z") },
  { "_id" : 3, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" : NumberInt( "10"), "date" : ISODate("2014-03-15T09:00:00Z") },
  { "_id" : 4, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" :  NumberInt("20") , "date" : ISODate("2014-04-04T11:21:39.736Z") },
  { "_id" : 5, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("10") , "date" : ISODate("2014-04-04T21:23:13.331Z") },
  { "_id" : 6, "item" : "def", "price" : NumberDecimal("7.5"), "quantity": NumberInt("5" ) , "date" : ISODate("2015-06-04T05:08:13Z") },
  { "_id" : 7, "item" : "def", "price" : NumberDecimal("7.5"), "quantity": NumberInt("10") , "date" : ISODate("2015-09-10T08:43:00Z") },
  { "_id" : 8, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : NumberInt("5" ) , "date" : ISODate("2016-02-06T20:20:13Z") },
])
```
通过如下语句可以统计出 `sale` 集合中总的文档数量:
```js
db.sales.aggregate( [
  {
    $group: {
       _id: null,
       count: { $count: { } }
    }
  }
] )
```
操作的执行结果如下:
```js
    { "_id" : null, "count" : 8 }
```
它与如下 SQL 语句等价:
```sql
    SELECT COUNT(*) AS count FROM sales;
```

#### 检索不同的值

通过在聚合操作中使用 `$group` 从 sales 集合中检索出指定字段下的不同值:
```js
db.sales.aggregate( [ { $group : { _id : "$item" } } ] )
```
上面的命令中指定字段为 "item"，检索出该字段对应值的所有不同值。操作的执行结果如下:
```js
    { "_id" : "abc" }
    { "_id" : "jkl" }
    { "_id" : "def" }
    { "_id" : "xyz" }
```
它与如下 SQL 语句等价:
```sql
    SELECT item FROM sales GROUP BY item;
```

#### 为分组结果指定条件

接下来的聚合操作会根据 "item" 字段将文档聚合，计算出每个 "item" 下的总销售量，之后只返回总销售量大于等于 100 的 "item" 文档:
```js
db.sales.aggregate(
  [
    // First Stage
    {
      $group :
        {
          _id : "$item",
          totalSaleAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } }
        }
     },
     // Second Stage
     {
       $match: { "totalSaleAmount": { $gte: 100 } }
     }
   ]
 )
```
上述命令一共有两个阶段。
- 第一阶段: `$group` 通过 "item" 字段聚合文档，并获得该字段下的所有不同值。该阶段的命令会返回如下结果:
```js
{ "_id" : "def", "totalSaleAmount" : NumberDecimal("112.5") }
{ "_id" : "abc", "totalSaleAmount" : NumberDecimal("170") }
{ "_id" : "jkl", "totalSaleAmount" : NumberDecimal("20") }
{ "_id" : "xyz", "totalSaleAmount" : NumberDecimal("150") }
```
- 第二阶段: `$match` 操作对第一阶段的执行结果根据 "totalSaleAmount" 进行过滤，只保留符合条件的。最终的执行结果如下:
```js
{ "_id" : "abc", "totalSaleAmount" : NumberDecimal("170") }
{ "_id" : "xyz", "totalSaleAmount" : NumberDecimal("150") }
{ "_id" : "def", "totalSaleAmount" : NumberDecimal("112.5") }
```
它与如下的 SQL 语句等价:
```sql
    SELECT item,
        SUM((price * quantity)) AS totalSaleAmount
    FROM sales
    GROUP BY item
    HAVING totalSaleAmount >= 100;
```

#### 计算总数/加和/平均数

接下来的管道操作会计算总的销售额、平均销售量以及 2014 年中每天的(平均)销售量:
```js
db.sales.aggregate([
  // First Stage
  {
    $match : { "date": { $gte: new ISODate("2014-01-01"), $lt: new ISODate("2015-01-01") } }
  },
  // Second Stage
  {
    $group : {
       _id : { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
       totalSaleAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } },
       averageQuantity: { $avg: "$quantity" },
       count: { $sum: 1 }
    }
  },
  // Third Stage
  {
    $sort : { totalSaleAmount: -1 }
  }
 ])
```
上述命名一共有三个阶段。
- 第一阶段: 利用 `$match` 过滤出 2014 年份的文档。执行后结果如下:
```js
    { "_id" : 1, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : 2, "date" : ISODate("2014-03-01T08:00:00Z") }
    { "_id" : 2, "item" : "jkl", "price" : NumberDecimal("20"), "quantity" : 1, "date" : ISODate("2014-03-01T09:00:00Z") }
    { "_id" : 3, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" : 10, "date" : ISODate("2014-03-15T09:00:00Z") }
    { "_id" : 4, "item" : "xyz", "price" : NumberDecimal("5"), "quantity" : 20, "date" : ISODate("2014-04-04T11:21:39.736Z") }
    { "_id" : 5, "item" : "abc", "price" : NumberDecimal("10"), "quantity" : 10, "date" : ISODate("2014-04-04T21:23:13.331Z") }
```
- 第二阶段: 利用 `$group` 对第一阶段结果进行 "date" 分组，计算出各组内的总销售额、平均销售量及总的销售量。执行后结果如下:
```js
    { "_id" : "2014-04-04", "totalSaleAmount" : NumberDecimal("200"), "averageQuantity" : 15, "count" : 2 }
    { "_id" : "2014-03-01", "totalSaleAmount" : NumberDecimal("40"), "averageQuantity" : 1.5, "count" : 2 }
    { "_id" : "2014-03-15", "totalSaleAmount" : NumberDecimal("50"), "averageQuantity" : 10, "count" : 1 }
```
- 第三阶段: `$sort` 对第二阶段结果根据 "totalSaleAmount" 降序排序。最后的执行结果如下:
```js
    { "_id" : "2014-04-04", "totalSaleAmount" : NumberDecimal("200"), "averageQuantity" : 15, "count" : 2 }
    { "_id" : "2014-03-15", "totalSaleAmount" : NumberDecimal("50"), "averageQuantity" : 10, "count" : 1 }
    { "_id" : "2014-03-01", "totalSaleAmount" : NumberDecimal("40"), "averageQuantity" : 1.5, "count" : 2 }
```
它与如下的 SQL 语句等价:
```sql
    SELECT date,
           SUM((price * quantity)) AS totalSaleAmount,
           AVG(quantity)           AS averageQuantity,
           COUNT(*)                AS Count
    FROM sales
    GROUP BY Date(date)
    ORDER BY totalSaleAmount DESC;
```

接下来的聚合操作通过将 "_id" 指定为 null，来达到计算文档中总的销售额、平均销量及总销售的目的。
```js
db.sales.aggregate([
  {
    $group : {
       _id : null,
       totalSaleAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } },
       averageQuantity: { $avg: "$quantity" },
       count: { $sum: 1 }
    }
  }
 ])
```
执行结果如下:
```js
    { "_id" : null, "totalSaleAmount" : NumberDecimal("452.5"), "averageQuantity" : 7.875, "count" : 8 }
```
它与如下的 SQL 语句等价:
```sql
    SELECT SUM(price * quantity) AS totalSaleAmount,
           AVG(quantity)         AS averageQuantity,
           COUNT(*)              AS Count
    FROM sales;
```

### 示例 - 更进一步使用

这可能是 SQL 中没有的语法。

创建一个示例集合:
```js
db.books.insertMany([
  { "_id" : 8751, "title" : "The Banquet", "author" : "Dante", "copies" : 2 },
  { "_id" : 8752, "title" : "Divine Comedy", "author" : "Dante", "copies" : 1 },
  { "_id" : 8645, "title" : "Eclogues", "author" : "Dante", "copies" : 2 },
  { "_id" : 7000, "title" : "The Odyssey", "author" : "Homer", "copies" : 10 },
  { "_id" : 7020, "title" : "Iliad", "author" : "Homer", "copies" : 10 }
])
```

接下来的聚合操作会以 "author" 作为分组字段，将每个分组中的 "title" 字段值导入到一个新的 "books" 字段中:
```js
db.books.aggregate([
   { $group : { _id : "$author", books: { $push: "$title" } } }
 ])
```
执行后结果如下:
```js
{ "_id" : "Homer", "books" : [ "The Odyssey", "Iliad" ] }
{ "_id" : "Dante", "books" : [ "The Banquet", "Divine Comedy", "Eclogues" ] }
```

接下来的聚合操作首先会以 "author" 作为分组字段，然后将分组中的每个文档记录导入到一个新的 "books" 字段中，最后在新的文档中添加一个新字段:
```js
db.books.aggregate([
   // First Stage
   {
     $group : { _id : "$author", books: { $push: "$$ROOT" } }
   },
   // Second Stage
   {
     $addFields:
       {
         totalCopies : { $sum: "$books.copies" }
       }
   }
 ])
```
- 第一阶段: `$group` 利用 `$$ROOT` 系统变量将整个文档添加到 "author" 分组。该阶段执行结果如下:
```js
{ "_id" : "Dante", "books" : [ { "_id" : 8751, "title" : "The Banquet", "author" : "Dante", "copies" : 2 }, { "_id" : 8752, "title" : "Divine Comedy", "author" : "Dante", "copies" : 1 }, { "_id" : 8645, "title" : "Eclogues", "author" : "Dante", "copies" : 2 } ] }
{ "_id" : "Homer", "books" : [ { "_id" : 7000, "title" : "The Odyssey", "author" : "Homer", "copies" : 10 }, { "_id" : 7020, "title" : "Iliad", "author" : "Homer", "copies" : 10 } ] }
```
- 第二阶段: `$addFields` 为一阶段输出结果中的每个 "author" 分组添加一个 "totalCopies" 字段，它代表了分组成的 "copies" 数量之和。最终的执行结果如下:
```js
{ "_id" : "Dante", "books" : [ { "_id" : 8751, "title" : "The Banquet", "author" : "Dante", "copies" : 2 }, { "_id" : 8752, "title" : "Divine Comedy", "author" : "Dante", "copies" : 1 }, { "_id" : 8645, "title" : "Eclogues", "author" : "Dante", "copies" : 2 } ], "totalCopies" : 5 }
{ "_id" : "Homer", "books" : [ { "_id" : 7000, "title" : "The Odyssey", "author" : "Homer", "copies" : 10 }, { "_id" : 7020, "title" : "Iliad", "author" : "Homer", "copies" : 10 } ], "totalCopies" : 20 }
```
