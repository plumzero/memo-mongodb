
### 参考

- [MongoDB InsertMany vs BlukWrite](https://stackoverflow.com/questions/35758690/mongodb-insertmany-vs-bulkwrite)
- [MongoDB中优雅删除大量数据的三种方式](https://www.jb51.net/article/226310.htm)


### 三种删除方式测试对比

- 总数量: 2010177
- 删除量: 1873490

|  删除方式  | 对应命令 | 耗时(毫秒)  |
|:-----------|:---------|:------------|
| deleteMany |   1      | 59745/47794 |
| bulkWrite  |   2      | 49592/57801/48585 |
| remove     |   3      | 47698/47063 |
| SQL 对比   |   4      | 57733/60060 |

1. `db.big_orders.deleteMany({ status : { "$eq": 4 } })`
2. `db.big_orders.bulkWrite([{ deleteMany: { "filter" : { status : { "$eq": 4 } } } }])`
3. `db.big_orders.remove({ status : { "$eq": 4 } })`
4. `delete from tbl_trade_order where "status"=4;`

- 比较 MongoDB 的各种删除方式的测试结果发现，并无太大差异。remove 看起来会快一点，但这是碰巧的结果，实际上官方已经弃用这种删除方式了，由 deleteOne 和 deleteMany 代替。blukWrite 是批量写操作，可以将插入、更新、删除等打包一起操作。
- 比较各种删除方式的慢操作日志(system.profile)会发现，它们的输出信息(字段)都是一致的。也就是说它们底层的删除机制可能都是一样的，只是叫法不同。
- 一般情况下都是使用 `deleteMany` 方法删除。接下来的测试也均使用此方法进行。


### 是否能够通过建立索引达到快速删除

这里为 "status" 字段建立索引:
```js
	db.big_orders.createIndex( { status: 1 } )
```

deleteMany 的非索引与建立索引删除对比。

删除条件字段是否有索引:

| 是否索引 | 执行方式 | 耗时(毫秒)  |
|:------|:---------|:------------|
| 有    | IXSCAN   | 62756/63952 |
| 否    | COLLSCAN | 59745/47794 |

可以看到:
- 有索引时采用的是索引扫描(IXSCAN)方式，无索引时采用的是全集合扫描(COLLSCAN)方式。
- 在删除条件字段存在索引时，删除操作可能还会进行其他耗时操作。

这里顺便测试一下删除条件字段为非索引字段，但其他字段存在索引的情况。

删除条件字段无索引，其他字段是否有索引:

| 是否索引 | 执行方式 | 耗时(毫秒)  |
|:------|:---------|:------------|
| 有    | COLLSCAN | 58620/59258 |
| 否    | COLLSCAN | 59745/47794 |

可以看出，非删除条件字段是否存在索引并不会影响删除效率。

### 尝试其他删除方式

还有没有其他的删除方式呢？

##### 设想一: 可不可以尝试先排序再删除:

```js
	db.big_orders.find({}).sort({status: 1}).deleteMany({status: { "$eq": 4 }})
```
上面的语句执行会报错，提示 `TypeError: db.big_orders.find(...).sort(...).deleteMany is not a function`，可能 deleteMany 前面只能跟集合。这与 SQL 中的 `delete from` 使用一致。

不可行。

##### 设想二: 通过聚合方式进行删除

就是先根据删除条件从原始集合创建一个临时集合，再将原始集合与这个临时集合聚合，通过 `unwind` 打平实现删除。临时集合保存的文档是符合删除条件值的反选集合，同时为了轻便，临时集合可以只存储删除条件字段。

不过，聚合删除的结果是对查询结果集的删除，并没有修改原始集合中的数据。且比较复杂。

不采用。

##### 设想三: 将某条文档更新为不可用(如修改某个字段)，进行软删除

比如这里将 "status" 字段修改(更新)为 0，来表明该记录不可用。

其更新情况与真正删除情况耗时对比如下:

注: 有三种更新方式，分别 `update`、`updateOne`、`updateMany`。同样地，`update` 已被弃用，由后两者代替。

| 执行方式 | 耗时(毫秒)  |
|:---------|:------------|
| updateMany(无索引) | 61261/61297 |
| updateMany(有索引) | 102163/102328 |
| deleteMany | 59745/47794 |

注: 为 "status" 字段建立索引。

updateMany 命令: 将 "status" 为 4 的文档更新为 0，达到'删除'目的。
```js
	db.big_orders.updateMany(
		{ status: { "$eq": 4 } },
		{ $set: { status: 0 } }
	)
```

可以看到:
- 无索引 updateMany 时的更新耗时与 deleteMany 相比无太大差异。
- 有索引 updateMany 时的更新比无索引更耗时。

不采用。

##### 设想四: findAndModify

只能删除满足条件的第一个文档。

不采用。

### 结论与建议

1. 条件删除没有太高效的方式，无论是 MongoDB 或者 SQL 。
2. 指定条件字段进行删除时，条件字段最好是无索引的。
3. 通过更新某字段使文档无效的方式来达到'删除'目的，并不比直接删除更高效。
4. 对于条件删除，使用 `deleteMany`。对于全集合删除，可以直接进行 `drop`。
