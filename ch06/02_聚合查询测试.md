
### 测试说明

1. 定义并创建集合 orders，文档数量内容与普通查询测试一致。
2. 定义并创建集合 transactions，共有文档数量 2269139 条。
3. 集合  中每个文档的结构示例:
  ```json
	{
		"id" : 10943775,
		"reqId" : 129350115,
		"orderId" : 51,
		"matchId" : 8,
		"time" : 93501093,
		"dealPrice" : 112500,
		"dealVolume" : 2400,
		"account_id" : 0,
		"fix_order" : "false",
		"Delay_Accept_Match" : 234,
		"serverId" : 12,
		"create_time" : "2021-10-29 09:35:03.521352+08",
		"modify_time" : "2021-10-29 09:35:03.521352+08",
		"available" : "t"
	}
  ```
4. 联结条件为 orders.id = transactions.reqId 。

### 测试环境

- MongoDB: 5.0.5
- 测试环境有两种: Ubuntu-16.04/Docker

### 测试样本

以 orders 作主表，transaction 作副表，联查:
```js
    db.big_orders.aggregate([
        {
            $lookup: {
                from: "big_transactions",
                localField: "id",
                foreignField: "reqId",
                as: "big_transactions"
            }
        },
		{
			$unwind: "$big_transactions"
		},
        {
            $match: {
                $and: [
                    { symbol: { $in: [603217, 887, 2743, 600768] } },
                    { status: { $in: [4, 7] } }
                ]
            }
        },
        {
            $sort: {
                submitTime: 1,
                modify_time: -1,
				"big_transactions.id": 1
            }
        },
        {
            $skip: 10
        },
        {
            $limit: 5
        },
        {
            $project: {
                _id: 0,
                id: 1,
                symbol: 1,
                status: 1,
                submitTime: 1,
                modify_time: 1,
                "big_transactions.id": 1
            }
        }
    ])
```
等价于 SQL:
```sql
    SELECT o."id",o."symbol",o."status",o."submitTime",o."modify_time",t."id" FROM big_orders AS o
        INNER JOIN big_transactions AS t
            ON o."id" = t."reqId"::BIGINT
                WHERE o."symbol" IN ('603217', '000887', '002743', '600768')
                    AND o."status" IN (4, 7)
						ORDER BY o."submitTime" ASC, o."modify_time" DESC, t."id" ASC
							OFFSET 10 LIMIT 5;
```

### 测试方法

- 在同一个 MongoDB 创建两个库，分别命名为 `online` 和 `offline`，前者作为测试库，后者作为对照库。
- 向两个库中分别写入集合 orders 和 transactions。
- 为 online.orders 中关联字段(orders.id 和 transactions.reqId)创建相关索引，命令如下:
  ```js
    use online
    db.getCollection("orders").createIndex( { id: 1 } )
    db.getCollection("transactions").createIndex( { reqId: 1 } )
  ```

### 测试记录

Ubuntu-16.04/Docker 机器上 online 与 offline 的测试结果对比:

耗时: 毫秒。

| 名称/耗时 | 耗时 |
|:---------|:-------|
| 有索引   | 2.384s |
| 无索引   | >37min |

### 补充测试

将 orders 和 transactions 导入到一个集合中，不妨命名为 mixed 。之后对 mixed 集合执行 `graphLookup` 操作:
```js
    db.mixed.aggregate([
        {
            $graphLookup: {
                from: "mixed",
                startWith: "$id",
                connectFromField: "id",
                connectToField: "reqId",
                as: "transactions"
            }
        },
        {
            $unwind: "$transactions"
        },
        {
            $match: {
                $and: [
                    { symbol: { $in: [603217, 887, 2743, 600768] } },
                    { status: { $in: [4, 7] } }
                ]
            }
        },
        {
            $sort: {
                submitTime: 1,
                modify_time: -1,
                "transactions.id": 1
            }
        },
        {
            $skip: 10
        },
        {
            $limit: 5
        },
        {
            $project: {
                _id: 0,
                id: 1,
                symbol: 1,
                status: 1,
                submitTime: 1,
                modify_time: 1,
                "transactions.id": 1
            }
        }
    ])
```

先进行无索引测试，再建立索引测试:
```js
    db.getCollection("mixed").createIndex( { id: 1 } )
    db.getCollection("mixed").createIndex( { reqId: 1 } )
```

| 名称/耗时 | 耗时 |
|:---------|:-------|
| 有索引   |  3秒    |
| 无索引   | >40min |

### 补充测试二

分别对比均建立索引的情况下，两个集合聚合与单集合聚合的情况。

- 转换情形测试时，要重启虚拟机和 mongod 实例/SQL 实例，避免热缓存影响。
- 同种情形测试时，不重启 mongod 实例/SQL 实例。

| 类型   | 第一次查询 | 第二次耗时 | 第三次耗时 | 第四次耗时 |
|:-------|:----------|:----------|:----------|:----------|
| 两集合 |  8.809s    | 1.884s    | 1.887s   | 1.878s     |
| 单集合 |  24.264s   | 3.427s    | 3.429s   | 3.535s     |
| SQL    | 12.144s    | 291.661ms | 282.254ms | 281.675ms |

注: 单集合和两集合测试在 ubuntu1604+docker 上进行，SQL 测试在 VMware+ubuntu1804 上进行。

### 测试结论

1. MongoDB 对一些联结字段设置索引，确实可以提高查询效率。
2. 初次查询时，要慢一点。后续由于缓存的影响，会好很多。
3. 总体来看，单集合比两集合慢一些，SQL 比单集合快一些。
