
利用关系型数据库可以实现多个表的内外联查，MongoDB 称通过 `$lookup` 也可以实现像关系型数据库一样的效果，不过实际上在 `$lookup` 后还需要进行一些处理才能达到视觉上与关系型数据库同样的效果。

这里创建两个测试表:
```sh
    db.table1.insert([
        { account: 111, id: 1 },
        { account: 222, id: 2 },
        { account: 333, id: 3 },
        { account: 111, id: 4 }
    ])
```

```sh
    db.table2.insert([
        { "accountid": 111, date: "20211227", group: "g1" },
        { "accountid": 111, date: "20211228", group: "g2" },
        { "accountid": 222, date: "20211227", group: "g1" },
        { "accountid": 222, date: "20211228", group: "g2" },
        { "accountid": 444, date: "20211227", group: "g1" },
        { "accountid": 444, date: "20211228", group: "g2" }
    ])
```

这里以 table1 作为主表，table2 作为副表进行联查，联查字段为 "table1.account" 和 "table2.accountid"。同时要求 "date" 为 "20211228" 。 

联查期望结果集为:
```json
    { "account": 111, "id": 1, "date": "20211228", "group": "g2" },
    { "account": 222, "id": 2, "date": "20211228", "group": "g2" },
    { "account": 111, "id": 4, "date": "20211228", "group": "g2" }
```

步骤如下。


### 第一步: 联查

该步骤的语句如下:
```sh
    db.table1.aggregate([
        {
            $lookup:
            {
                from: "table2",
                localField: "account",
                foreignField: "accountid",
                as: "table2"
            }
        }
    ])
```
主表已经通过 `db.table1` 指定，其他字段意义如下:
- `from`: 指定副表
- `localField`: 指定主表联查键
- `foreignField`: 指定副表联查键
- `as`: 副表的别名，不能为空，在接下来的语句中会用到，可以定义为与 `from` 内容相同

执行后输出如下:
```json
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0eb"), "account" : 111, "id" : 1, "table2" : [ { "_id" : ObjectId("61cd27d852a3c7705ffdf0ef"), "accountid" : 111, "date" : "20211227", "group" : "g1" }, { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } ] }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ec"), "account" : 222, "id" : 2, "table2" : [ { "_id" : ObjectId("61cd27d852a3c7705ffdf0f1"), "accountid" : 222, "date" : "20211227", "group" : "g1" }, { "_id" : ObjectId("61cd27d852a3c7705ffdf0f2"), "accountid" : 222, "date" : "20211228", "group" : "g2" } ] }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ed"), "account" : 333, "id" : 3, "table2" : [ ] }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ee"), "account" : 111, "id" : 4, "table2" : [ { "_id" : ObjectId("61cd27d852a3c7705ffdf0ef"), "accountid" : 111, "date" : "20211227", "group" : "g1" }, { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } ] }
```
可以看到有 4 行输出，前两行和最后一行记录中的 "table2" 字段值不为空，第三行记录中 "table2" 字段值为空。

执行结果符合预期，只是有点混乱。

"table2" 字段值类型是一个数组，数组元素是对象，对象中的元素处于整个 json 层级的第2级(假设 "table2" 是第1级的话)。为了将数组元素中的字段置为第1级，需要对数组进行展开，以便使用 `$replaceWith` 操作。


### 第二步: 展开

可以使用 `$unwind` 进行，完整语句如下:
```sh
    db.table1.aggregate([
        {
            $lookup:
            {
                from: "table2",
                localField: "account",
                foreignField: "accountid",
                as: "table2"
            }
        },
        {
            $unwind: "$table2"
        }
    ])
```
执行后输出如下:
```json
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0eb"), "account" : 111, "id" : 1, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0ef"), "accountid" : 111, "date" : "20211227", "group" : "g1" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0eb"), "account" : 111, "id" : 1, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ec"), "account" : 222, "id" : 2, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f1"), "accountid" : 222, "date" : "20211227", "group" : "g1" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ec"), "account" : 222, "id" : 2, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f2"), "accountid" : 222, "date" : "20211228", "group" : "g2" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ee"), "account" : 111, "id" : 4, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0ef"), "accountid" : 111, "date" : "20211227", "group" : "g1" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ee"), "account" : 111, "id" : 4, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } }
```
这里可以看到，输出整齐了一些，并且因为对 "table2" 的展开效果，会自动把为空的值去掉，节省了一步匹配(过滤)的操作。

接下来既可以进行匹配操作("date" 值)，也可以进行 json 提升操作(不妨称为摊平)。这里选择先进行匹配。


### 第三步: 匹配过滤

使用 `$match`，完整语句如下:
```sh
    db.table1.aggregate([
        {
            $lookup:
            {
                from: "table2",
                localField: "account",
                foreignField: "accountid",
                as: "table2"
            }
        },
        {
            $unwind: "$table2"
        },
        {
            $match: { "table2.date": { $eq: "20211228" } }
        }
    ])
```
输出如下:
```json
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0eb"), "account" : 111, "id" : 1, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ec"), "account" : 222, "id" : 2, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f2"), "accountid" : 222, "date" : "20211228", "group" : "g2" } }
    { "_id" : ObjectId("61cd279e52a3c7705ffdf0ee"), "account" : 111, "id" : 4, "table2" : { "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" } }
```


### 第四步: 摊平

使用 `$replaceWith`，完整语句如下:
```sh
    db.table1.aggregate([
        {
            $lookup:
            {
                from: "table2",
                localField: "account",
                foreignField: "accountid",
                as: "table2"
            }
        },
        {
            $unwind: "$table2"
        },
        {
            $match: { "table2.date": { $eq: "20211228" } }
        },
        {
            $replaceWith: { $mergeObjects: [ { account: "$account", id: "$id" }, "$table2" ] }
        }
    ])
```
输出如下:
```json
    { "account" : 111, "id" : 1, "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" }
    { "account" : 222, "id" : 2, "_id" : ObjectId("61cd27d852a3c7705ffdf0f2"), "accountid" : 222, "date" : "20211228", "group" : "g2" }
    { "account" : 111, "id" : 4, "_id" : ObjectId("61cd27d852a3c7705ffdf0f0"), "accountid" : 111, "date" : "20211228", "group" : "g2" }
```
可以看到，原先处于第2级的 "date" 等字段已经被提升到了第1级，而第1级中的 "table2" 也消失了。

不过仍有一些多余字段，比如 "_id", "accountid" 等，是不用输出的。

这可以通过如下方式进行控制。


### 第五步: 选择性输出

使用 `$project`，完整语句(这也是最终的语句)如下:
```sh
    db.table1.aggregate([
        {
            $lookup:
            {
                from: "table2",
                localField: "account",
                foreignField: "accountid",
                as: "table2"
            }
        },
        {
            $unwind: "$table2"
        },
        {
            $match: { "table2.date": { $eq: "20211228" } }
        },
        {
            $replaceWith: { $mergeObjects: [ { account: "$account", id: "$id" }, "$table2" ] }
        },
        {
            $project: {
                _id: 0,
                account: 1,
                id: 1,
                date: 1,
                group: 1
            }
        }
    ])
```
执行后输出如下:
```json
    { "account" : 111, "id" : 1, "date" : "20211228", "group" : "g2" }
    { "account" : 222, "id" : 2, "date" : "20211228", "group" : "g2" }
    { "account" : 111, "id" : 4, "date" : "20211228", "group" : "g2" }
```
因为在执行了第四步之后，"date", "group"等字段已经被提升到了第1级，所以在 `$project` 中不需要再指定 `table2` 前缀(不过`table2`也没有了)。


### 后记

- 本示例等价 SQL 语句为:
  ```sql
    select o."account", o."id", t."date", t."group" from table1 as o inner join table2 as t on o."account" = t."accountid" where t."date" = '20211228';
  ```

另外，[这里](lookup与SQL对等语句.md)再提供一些与 lookup 对等的 SQL 语句。